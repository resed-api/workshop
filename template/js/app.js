// Terminal Application
const output = document.getElementById('output');
const input = document.getElementById('command-input');
const terminal = document.getElementById('terminal');
const contentDisplay = document.getElementById('content-display');
const promptText = document.getElementById('prompt-text');
const mobileTitle = document.getElementById('mobile-title');

let commandHistory = [];
let historyIndex = -1;
let currentSection = null;
let sectionsLoaded = false;

// Get config from generated file
const config = window.CONFERENCE_CONFIG || {
    conference: { title: 'Conference', subtitle: '' },
    terminal: { username: 'conference', hostname: 'terminal' },
    dates: { start: '', end: '' },
    venue: { city: '' },
    sections: [
        { id: 'about', label: 'About', icon: 'â„¹ï¸' },
        { id: 'program', label: 'Program', icon: 'ðŸ“…' },
        { id: 'venue', label: 'Venue', icon: 'ðŸ“' },
        { id: 'hotels', label: 'Hotels', icon: 'ðŸ¨' }
    ],
    themes: [{ id: 'classic', name: 'Classic Green' }],
    contact: { email: '', website: '' }
};

// Content sections (will be populated by build process)
const sections = {};

// Build available commands from config
const availableCommands = ['home', ...config.sections.map(s => s.id), 'help', 'download', 'clear'];

// Helper: escapeHtml and conservative linkify for help text only
function escapeHtml(str) {
    return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

function linkify(text) {
    const escaped = escapeHtml(text);
    const withLinks = escaped.replace(/(https?:\/\/[^\s<]+)/g, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
    return withLinks.replace(/\n/g, '<br>');
}

// Generate welcome message with dynamic padding
function generateWelcomeMessage() {
    const title = config.conference.title || 'Conference';
    const dates = config.dates.start && config.dates.end
        ? `${config.dates.start} - ${config.dates.end}`
        : '';
    const city = config.venue.city || '';
    
    const instructions = [
        "Type 'help' to see available commands",
        "Use arrow keys (â†‘â†“) for command history",
        "Press TAB for command completion",
        "Click navigation buttons above for quick access"
    ];
    
    // Calculate the longest line to determine box width
    const allLines = [title, dates, city, ...instructions].filter(Boolean);
    const maxLength = Math.max(...allLines.map(l => l.length));
    const boxWidth = Math.max(maxLength + 4, 59); // Min 59 chars wide
    const innerWidth = boxWidth - 4; // Account for "â•‘  " on both sides
    
    const topBorder = 'â•”' + 'â•'.repeat(boxWidth - 2) + 'â•—';
    const bottomBorder = 'â•š' + 'â•'.repeat(boxWidth - 2) + 'â•';
    const emptyLine = 'â•‘' + ' '.repeat(boxWidth - 2) + 'â•‘';
    
    const padLine = (text) => 'â•‘  ' + text.padEnd(innerWidth, ' ') + 'â•‘';
    
    let message = '\n' + topBorder + '\n';
    message += padLine(title) + '\n';
    if (dates) message += padLine(dates) + '\n';
    if (city) message += padLine(city) + '\n';
    message += emptyLine + '\n';
    instructions.forEach(line => {
        message += padLine(line) + '\n';
    });
    message += bottomBorder + '\n';
    
    return message;
}

// Show mobile title (CSS controls visibility based on screen size)
function showMobileTitle() {
    if (mobileTitle) {
        mobileTitle.classList.remove('hidden');
    }
}

// Hide mobile title
function hideMobileTitle() {
    if (mobileTitle) {
        mobileTitle.classList.add('hidden');
    }
}

// Initialize
window.addEventListener('DOMContentLoaded', async () => {
    printOutput(generateWelcomeMessage(), 'help-text welcome-box');
    showMobileTitle(); // CSS will control if it actually shows
    
    // Load content first, then check hash
    await loadContent();
    
    // Now check for hash in URL
    const hash = window.location.hash;
    if (hash && hash.startsWith('#/')) {
        const parts = hash.substring(2).split('#');
        const command = parts[0];
        const anchor = parts[1];
        
        if (sections[command]) {
            executeCommand(command, false);
            
            // Scroll to anchor if present
            if (anchor) {
                setTimeout(() => {
                    const element = document.getElementById(anchor);
                    if (element) {
                        element.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                }, 300);
            }
        }
    }
    
    setupNavButtons();
    setupThemeSwitcher();
    
    // Focus input
    input.focus();
});

// Load content from sections.json (generated by build process)
async function loadContent() {
    try {
        const response = await fetch('sections.json');
        if (response.ok) {
            const data = await response.json();
            Object.assign(sections, data);
            sectionsLoaded = true;
            console.log('âœ“ Sections loaded:', Object.keys(sections));
        } else {
            console.error('âœ— Failed to load sections.json:', response.status);
        }
    } catch (e) {
        console.error('âœ— Error loading content:', e);
    }
    sectionsLoaded = true;
}

// Setup navigation buttons
function setupNavButtons() {
    document.querySelectorAll('.nav-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.preventDefault();
            const cmd = btn.getAttribute('data-cmd');
            if (cmd) {
                input.value = cmd;
                executeCommandFromInput();
            }
        });
    });
}

// Setup theme switcher
function setupThemeSwitcher() {
    const themeToggle = document.getElementById('theme-toggle');
    const themeMenu = document.getElementById('theme-menu');
    
    if (!themeToggle || !themeMenu) return;
    
    // Load saved theme or use default from config
    const defaultTheme = config.themes.find(t => t.default)?.id || 'classic';
    const savedTheme = localStorage.getItem('terminal-theme') || defaultTheme;
    document.documentElement.setAttribute('data-theme', savedTheme);
    
    themeToggle.addEventListener('click', (e) => {
        e.stopPropagation();
        themeMenu.classList.toggle('hidden');
    });
    
    document.querySelectorAll('[data-theme]').forEach(btn => {
        btn.addEventListener('click', () => {
            const theme = btn.getAttribute('data-theme');
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('terminal-theme', theme);
            themeMenu.classList.add('hidden');
        });
    });
    
    // Close menu when clicking outside
    document.addEventListener('click', () => {
        themeMenu.classList.add('hidden');
    });
}

// Command input handler with tab completion
input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        executeCommandFromInput();
    } else if (e.key === 'Tab') {
        e.preventDefault();
        handleTabCompletion();
    } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (historyIndex > 0) {
            historyIndex--;
            input.value = commandHistory[historyIndex];
        }
    } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (historyIndex < commandHistory.length - 1) {
            historyIndex++;
            input.value = commandHistory[historyIndex];
        } else {
            historyIndex = commandHistory.length;
            input.value = '';
        }
    }
});

// Execute command from input
function executeCommandFromInput() {
    const command = input.value.trim().toLowerCase();
    if (command) {
        historyIndex = commandHistory.length;
        executeCommand(command, true);
        input.value = '';
    }
}

// Tab completion - Show all options if no input
function handleTabCompletion() {
    const partial = input.value.toLowerCase();
    
    // If no input, show all available commands
    if (partial === '') {
        printOutput(`\nAvailable commands: ${availableCommands.join(', ')}`, 'help-text');
        scrollToBottom();
        return;
    }
    
    const matches = availableCommands.filter(cmd => cmd.startsWith(partial));
    
    if (matches.length === 1) {
        input.value = matches[0];
    } else if (matches.length > 1) {
        printOutput(`\nPossible commands: ${matches.join(', ')}`, 'help-text');
        scrollToBottom();
    } else {
        printOutput(`\nNo commands match: ${partial}`, 'error');
        scrollToBottom();
    }
}

// Echo command to output
function echoCommand(command) {
    const commandDiv = document.createElement('div');
    commandDiv.className = 'command-echo';
    const promptPrefix = promptText.textContent;
    commandDiv.innerHTML = `<span class="prompt">${promptPrefix}</span> ${command}`;
    output.appendChild(commandDiv);
}

// Update prompt with breadcrumb
function updatePrompt(section = null) {
    currentSection = section;
    const username = config.terminal.username;
    const hostname = config.terminal.hostname;
    
    if (section) {
        promptText.textContent = `${username}@${hostname}:~/${section}$`;
    } else {
        promptText.textContent = `${username}@${hostname}:~$`;
    }
}

// Execute command
function executeCommand(command, updateHash = true) {
    // Echo command if not already in history
    if (!commandHistory.includes(command) || commandHistory[commandHistory.length - 1] !== command) {
        echoCommand(command);
        if (command !== 'clear' && command !== 'home') {
            commandHistory.push(command);
        }
    }
    
    if (updateHash && command !== 'clear' && command !== 'home') {
        window.location.hash = '#/' + command;
    }
    
    switch (command) {
        case 'home':
            goHome();
            break;
        case 'help':
            showHelp();
            updatePrompt(null);
            hideMobileTitle();
            break;
	case 'download':
    	    downloadContent();
    	    updatePrompt(null);
    	    hideMobileTitle();
    	    break;
        case 'clear':
            output.innerHTML = '';
            contentDisplay.innerHTML = '';
            contentDisplay.classList.add('hidden');
            updatePrompt(null);
            window.location.hash = '';
            showMobileTitle();
            break;
        default:
            if (availableCommands.includes(command)) {
                showSection(command);
                updatePrompt(command);
                hideMobileTitle();
            } else {
                printOutput(`Command not found: ${command}. Type 'help' for available commands.`, 'error');
            }
    }
    
    scrollToBottom();
}

// Go home
function goHome() {
    output.innerHTML = '';
    contentDisplay.innerHTML = '';
    contentDisplay.classList.add('hidden');
    printOutput(generateWelcomeMessage(), 'help-text welcome-box');
    updatePrompt(null);
    window.location.hash = '';
    showMobileTitle();
}

// Show help
function showHelp() {
    const commandList = config.sections.map(s =>
        `  ${s.id.padEnd(12)} ${s.label}`
    ).join('\n');
    
    const helpText = `
${config.conference.title}
${config.conference.subtitle}

Available commands:

  home         Return to welcome screen
${commandList}
  help         Show this help message
  download     Download full program (PDF or print version)
  clear        Clear the terminal screen

Navigation:
  - Type commands and press ENTER
  - Press TAB for command completion
  - Use â†‘â†“ arrow keys for command history
  - Click navigation buttons at the top
  - Direct URLs work: #/about, #/program, etc.

Themes:
  - Click ðŸŽ¨ Theme button to change color scheme
  - ${config.themes.length} accessible themes available

Printing:
  - Use your browser's print function (Ctrl+P / Cmd+P)
  - Only the content area will be printed

Contact: ${config.contact.email || 'N/A'}
Website: ${config.contact.website || 'N/A'}
${config.contact.repository ? `Code base: ${config.contact.repository}` : ''}
`;
    printHelpText(helpText);
    contentDisplay.innerHTML = '';
    contentDisplay.classList.add('hidden');
}

// Download PDF
// Download content - prefers PDF, falls back to print.html
function downloadContent() {
    const pdfUrl = 'conference-content.pdf';
    const htmlUrl = 'print.html';
    
    // Try PDF first
    fetch(pdfUrl, { method: 'HEAD' })
        .then(response => {
            if (response.ok) {
                // PDF available
                printOutput(`âœ“ Downloading ${config.conference.title} - Full Program (PDF)`, 'success');
                window.open(pdfUrl, '_blank');
            } else {
                // Fall back to print.html
                printOutput(`âœ“ Opening printable version in new tab`, 'success');
                printOutput(`  Use your browser's print function (Ctrl+P / Cmd+P) to save as PDF`, 'help-text');
                window.open(htmlUrl, '_blank');
            }
        })
        .catch(() => {
            // Network error, try print.html as fallback
            printOutput(`âœ“ Opening printable version in new tab`, 'success');
            printOutput(`  Use your browser's print function (Ctrl+P / Cmd+P) to save as PDF`, 'help-text');
            window.open(htmlUrl, '_blank');
        });
    
    contentDisplay.innerHTML = '';
    contentDisplay.classList.add('hidden');
}

// Show content section with title
function showSection(section) {
    console.log('showSection called with:', section);
    console.log('Available sections:', Object.keys(sections));
    console.log('Section content exists:', !!sections[section]);
    
    if (sections[section]) {
        // Get section label from config
        const sectionConfig = config.sections.find(s => s.id === section);
        const label = sectionConfig ? sectionConfig.label : section.charAt(0).toUpperCase() + section.slice(1);
        
        // Clear and prepare content display
        contentDisplay.innerHTML = '';
        contentDisplay.classList.remove('maximized'); // Reset maximized state
        
        // Add maximize button
        const maximizeBtn = document.createElement('button');
        maximizeBtn.className = 'content-maximize-btn';
        maximizeBtn.innerHTML = 'â¤¢'; // Maximize icon
        maximizeBtn.title = 'Maximize content';
        maximizeBtn.onclick = () => toggleMaximize(maximizeBtn);
        contentDisplay.appendChild(maximizeBtn);
        
        // Add title to content
        const titleElement = document.createElement('h1');
        titleElement.className = 'content-title';
        titleElement.textContent = label;
        contentDisplay.appendChild(titleElement);
        
        // Add section content with anchors
        const contentWrapper = document.createElement('div');
        contentWrapper.className = 'content-body';
        contentWrapper.innerHTML = addSectionAnchors(sections[section]);
        contentDisplay.appendChild(contentWrapper);
        
        // Show content area
        contentDisplay.classList.remove('hidden');
        
        // Print brief success message in terminal
        printOutput(`âœ“ Loaded: ${label}`, 'success');
    } else {
        console.error('Section not found:', section);
        printOutput(`âœ— Content for '${section}' is not available yet.`, 'error');
        contentDisplay.innerHTML = '';
        contentDisplay.classList.add('hidden');
    }
}

// Toggle maximize/restore content display
function toggleMaximize(button) {
    contentDisplay.classList.toggle('maximized');
    
    if (contentDisplay.classList.contains('maximized')) {
        button.innerHTML = 'â¤¡'; // Restore icon
        button.title = 'Restore content';
    } else {
        button.innerHTML = 'â¤¢'; // Maximize icon
        button.title = 'Maximize content';
    }
}

// Add anchors to section headings - preserve hash routing
function addSectionAnchors(html) {
    const temp = document.createElement('div');
    temp.innerHTML = html;
    
    temp.querySelectorAll('h1, h2, h3').forEach(heading => {
        const text = heading.textContent;
        const id = text.toLowerCase().replace(/[^\w]+/g, '-');
        heading.id = id;
        
        // Add link icon that preserves section in URL
        const link = document.createElement('a');
        link.href = `#/${currentSection}#${id}`;
        link.className = 'section-link';
        link.innerHTML = ' ðŸ”—';
        link.title = `Link to ${text}`;
        link.onclick = (e) => {
            e.preventDefault();
            // Update hash without changing section
            const url = new URL(window.location);
            url.hash = `/${currentSection}#${id}`;
            window.history.pushState(null, '', url);
            // Scroll to element
            heading.scrollIntoView({ behavior: 'smooth', block: 'start' });
        };
        heading.appendChild(link);
    });
    
    return temp.innerHTML;
}

// Print output (for messages, not content)
function printOutput(text, className = '') {
    const outputDiv = document.createElement('div');
    outputDiv.className = 'output-block ' + className;
    outputDiv.textContent = text;
    output.appendChild(outputDiv);
}

// Print help (sanitized, linkified)
function printHelpText(rawText) {
    const out = document.getElementById('output');
    const block = document.createElement('div');
    block.className = 'output-block help-text';
    block.innerHTML = linkify(rawText);
    out.appendChild(block);
}

// Scroll to bottom
function scrollToBottom() {
    setTimeout(() => {
        window.scrollTo({
            top: document.body.scrollHeight,
            behavior: 'smooth'
        });
    }, 100);
}

// Handle hash changes
window.addEventListener('hashchange', async () => {
    const hash = window.location.hash;
    if (hash && hash.startsWith('#/')) {
        const parts = hash.substring(2).split('#');
        const command = parts[0];
        const anchor = parts[1];
        
        // Wait for sections to load if needed
        if (!sectionsLoaded) {
            await loadContent();
        }
        
        if (sections[command]) {
            // Only process if this is a manual hash change (not from our executeCommand)
            // Check if last command in history matches
            const isManualHashChange = !commandHistory.length || commandHistory[commandHistory.length - 1] !== command;
            
            if (isManualHashChange) {
                commandHistory.push(command);
                historyIndex = commandHistory.length;
                echoCommand(command);
                executeCommand(command, false);
            }
            
            // Scroll to anchor if present
            if (anchor) {
                setTimeout(() => {
                    const element = document.getElementById(anchor);
                    if (element) {
                        element.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                }, 200);
            }
        }
    }
});

// Keep input focused when clicking outside interactive areas, but don't steal focus/selection
document.addEventListener('click', (e) => {
    // If user clicked inside theme controls, top nav, content display or output, don't force-focus input.
    if (e.target.closest('#theme-menu') ||
        e.target.closest('#theme-toggle') ||
        e.target.closest('.top-nav') ||
        e.target.closest('#content-display') ||
        e.target.closest('#output')) {
        return;
    }
    const cmd = document.getElementById('command-input');
    if (cmd) cmd.focus();
});

// Defensive: do not focus input on mousedown (this would steal selection)
document.addEventListener('mousedown', (e) => {
    if (e.target.closest('#content-display') || e.target.closest('#output')) {
        // allow native selection to proceed â€” do not change focus
        return;
    }
    // otherwise no-op here; click handler will focus on click
});

// Make input more obvious - pulse animation
setInterval(() => {
    if (document.activeElement !== input) {
        input.classList.add('pulse');
        setTimeout(() => input.classList.remove('pulse'), 1000);
    }
}, 5000);

// Global keyboard shortcuts
document.addEventListener('keydown', (e) => {
    // ESC to exit maximized view
    if (e.key === 'Escape' && contentDisplay.classList.contains('maximized')) {
        const maximizeBtn = contentDisplay.querySelector('.content-maximize-btn');
        if (maximizeBtn) {
            toggleMaximize(maximizeBtn);
        }
    }
});
